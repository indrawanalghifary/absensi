"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hotkeys-js";
exports.ids = ["vendor-chunks/hotkeys-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/hotkeys-js/dist/hotkeys.esm.js":
/*!*****************************************************!*\
  !*** ./node_modules/hotkeys-js/dist/hotkeys.esm.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ hotkeys)\n/* harmony export */ });\n/**! \n * hotkeys-js v3.13.15 \n * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies. \n * \n * Copyright (c) 2025 kenny wong <wowohoo@qq.com> \n * https://github.com/jaywcjlove/hotkeys-js.git \n * \n * @website: https://jaywcjlove.github.io/hotkeys-js\n \n * Licensed under the MIT license \n */\n\nconst isff = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase().indexOf('firefox') > 0 : false;\n\n/** Bind event */\nfunction addEvent(object, event, method, useCapture) {\n  if (object.addEventListener) {\n    object.addEventListener(event, method, useCapture);\n  } else if (object.attachEvent) {\n    object.attachEvent(\"on\".concat(event), method);\n  }\n}\nfunction removeEvent(object, event, method, useCapture) {\n  if (object.removeEventListener) {\n    object.removeEventListener(event, method, useCapture);\n  } else if (object.detachEvent) {\n    object.detachEvent(\"on\".concat(event), method);\n  }\n}\n\n/** Convert modifier keys to their corresponding key codes */\nfunction getMods(modifier, key) {\n  const mods = key.slice(0, key.length - 1);\n  for (let i = 0; i < mods.length; i++) mods[i] = modifier[mods[i].toLowerCase()];\n  return mods;\n}\n\n/** Process the input key string and convert it to an array */\nfunction getKeys(key) {\n  if (typeof key !== 'string') key = '';\n  key = key.replace(/\\s/g, ''); // Match any whitespace character, including spaces, tabs, form feeds, etc.\n  const keys = key.split(','); // Allow multiple shortcuts separated by ','\n  let index = keys.lastIndexOf('');\n\n  // Shortcut may include ',' — special handling needed\n  for (; index >= 0;) {\n    keys[index - 1] += ',';\n    keys.splice(index, 1);\n    index = keys.lastIndexOf('');\n  }\n  return keys;\n}\n\n/** Compare arrays of modifier keys */\nfunction compareArray(a1, a2) {\n  const arr1 = a1.length >= a2.length ? a1 : a2;\n  const arr2 = a1.length >= a2.length ? a2 : a1;\n  let isIndex = true;\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr2.indexOf(arr1[i]) === -1) isIndex = false;\n  }\n  return isIndex;\n}\n\n// Special Keys\nconst _keyMap = {\n  backspace: 8,\n  '⌫': 8,\n  tab: 9,\n  clear: 12,\n  enter: 13,\n  '↩': 13,\n  return: 13,\n  esc: 27,\n  escape: 27,\n  space: 32,\n  left: 37,\n  up: 38,\n  right: 39,\n  down: 40,\n  /// https://w3c.github.io/uievents/#events-keyboard-key-location\n  arrowup: 38,\n  arrowdown: 40,\n  arrowleft: 37,\n  arrowright: 39,\n  del: 46,\n  delete: 46,\n  ins: 45,\n  insert: 45,\n  home: 36,\n  end: 35,\n  pageup: 33,\n  pagedown: 34,\n  capslock: 20,\n  num_0: 96,\n  num_1: 97,\n  num_2: 98,\n  num_3: 99,\n  num_4: 100,\n  num_5: 101,\n  num_6: 102,\n  num_7: 103,\n  num_8: 104,\n  num_9: 105,\n  num_multiply: 106,\n  num_add: 107,\n  num_enter: 108,\n  num_subtract: 109,\n  num_decimal: 110,\n  num_divide: 111,\n  '⇪': 20,\n  ',': 188,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '-': isff ? 173 : 189,\n  '=': isff ? 61 : 187,\n  ';': isff ? 59 : 186,\n  '\\'': 222,\n  '{': 219,\n  '}': 221,\n  '[': 219,\n  ']': 221,\n  '\\\\': 220\n};\n\n// Modifier Keys\nconst _modifier = {\n  // shiftKey\n  '⇧': 16,\n  shift: 16,\n  // altKey\n  '⌥': 18,\n  alt: 18,\n  option: 18,\n  // ctrlKey\n  '⌃': 17,\n  ctrl: 17,\n  control: 17,\n  // metaKey\n  '⌘': 91,\n  cmd: 91,\n  meta: 91,\n  command: 91\n};\nconst modifierMap = {\n  16: 'shiftKey',\n  18: 'altKey',\n  17: 'ctrlKey',\n  91: 'metaKey',\n  shiftKey: 16,\n  ctrlKey: 17,\n  altKey: 18,\n  metaKey: 91\n};\nconst _mods = {\n  16: false,\n  18: false,\n  17: false,\n  91: false\n};\nconst _handlers = {};\n\n// F1~F12 special key\nfor (let k = 1; k < 20; k++) {\n  _keyMap[\"f\".concat(k)] = 111 + k;\n}\n\n/** Record the pressed keys */\nlet _downKeys = [];\n/** Whether the window has already listened to the focus event */\nlet winListendFocus = null;\n/** Default hotkey scope */\nlet _scope = 'all';\n/** Map to record elements with bound events */\nconst elementEventMap = new Map();\n\n/** Return key code */\nconst code = x => _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);\nconst getKey = x => Object.keys(_keyMap).find(k => _keyMap[k] === x);\nconst getModifier = x => Object.keys(_modifier).find(k => _modifier[k] === x);\n\n/** Set or get the current scope (defaults to 'all') */\nfunction setScope(scope) {\n  _scope = scope || 'all';\n}\n/** Get the current scope */\nfunction getScope() {\n  return _scope || 'all';\n}\n/** Get the key codes of the currently pressed keys */\nfunction getPressedKeyCodes() {\n  return _downKeys.slice(0);\n}\nfunction getPressedKeyString() {\n  return _downKeys.map(c => getKey(c) || getModifier(c) || String.fromCharCode(c));\n}\nfunction getAllKeyCodes() {\n  const result = [];\n  Object.keys(_handlers).forEach(k => {\n    _handlers[k].forEach(_ref => {\n      let {\n        key,\n        scope,\n        mods,\n        shortcut\n      } = _ref;\n      result.push({\n        scope,\n        shortcut,\n        mods,\n        keys: key.split('+').map(v => code(v))\n      });\n    });\n  });\n  return result;\n}\n\n/** hotkey is effective only when filter return true */\nfunction filter(event) {\n  const target = event.target || event.srcElement;\n  const {\n    tagName\n  } = target;\n  let flag = true;\n  const isInput = tagName === 'INPUT' && !['checkbox', 'radio', 'range', 'button', 'file', 'reset', 'submit', 'color'].includes(target.type);\n  // ignore: isContentEditable === 'true', <input> and <textarea> when readOnly state is false, <select>\n  if (target.isContentEditable || (isInput || tagName === 'TEXTAREA' || tagName === 'SELECT') && !target.readOnly) {\n    flag = false;\n  }\n  return flag;\n}\n\n/** Determine whether the pressed key matches a specific key, returns true or false */\nfunction isPressed(keyCode) {\n  if (typeof keyCode === 'string') {\n    keyCode = code(keyCode); // Convert to key code\n  }\n  return _downKeys.indexOf(keyCode) !== -1;\n}\n\n/** Loop through and delete all handlers with the specified scope */\nfunction deleteScope(scope, newScope) {\n  let handlers;\n  let i;\n\n  // If no scope is specified, get the current scope\n  if (!scope) scope = getScope();\n  for (const key in _handlers) {\n    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {\n      handlers = _handlers[key];\n      for (i = 0; i < handlers.length;) {\n        if (handlers[i].scope === scope) {\n          const deleteItems = handlers.splice(i, 1);\n          deleteItems.forEach(_ref2 => {\n            let {\n              element\n            } = _ref2;\n            return removeKeyEvent(element);\n          });\n        } else {\n          i++;\n        }\n      }\n    }\n  }\n\n  // If the current scope has been deleted, reset the scope to 'all'\n  if (getScope() === scope) setScope(newScope || 'all');\n}\n\n/** Clear modifier keys */\nfunction clearModifier(event) {\n  let key = event.keyCode || event.which || event.charCode;\n  if (event.key && event.key.toLowerCase() === 'capslock') {\n    // Ensure that when capturing keystrokes in modern browsers,\n    // uppercase and lowercase letters (such as R and r) return the same key value.\n    // https://github.com/jaywcjlove/hotkeys-js/pull/514\n    // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n    key = code(event.key);\n  }\n  const i = _downKeys.indexOf(key);\n\n  // Remove the pressed key from the list\n  if (i >= 0) {\n    _downKeys.splice(i, 1);\n  }\n  // Special handling for the command key: fix the issue where keyup only triggers once for command combos\n  if (event.key && event.key.toLowerCase() === 'meta') {\n    _downKeys.splice(0, _downKeys.length);\n  }\n\n  // Clear modifier keys: shiftKey, altKey, ctrlKey, (command || metaKey)\n  if (key === 93 || key === 224) key = 91;\n  if (key in _mods) {\n    _mods[key] = false;\n\n    // Reset the modifier key status to false\n    for (const k in _modifier) if (_modifier[k] === key) hotkeys[k] = false;\n  }\n}\nfunction unbind(keysInfo) {\n  // unbind(), unbind all keys\n  if (typeof keysInfo === 'undefined') {\n    Object.keys(_handlers).forEach(key => {\n      Array.isArray(_handlers[key]) && _handlers[key].forEach(info => eachUnbind(info));\n      delete _handlers[key];\n    });\n    removeKeyEvent(null);\n  } else if (Array.isArray(keysInfo)) {\n    // support like : unbind([{key: 'ctrl+a', scope: 's1'}, {key: 'ctrl-a', scope: 's2', splitKey: '-'}])\n    keysInfo.forEach(info => {\n      if (info.key) eachUnbind(info);\n    });\n  } else if (typeof keysInfo === 'object') {\n    // support like unbind({key: 'ctrl+a, ctrl+b', scope:'abc'})\n    if (keysInfo.key) eachUnbind(keysInfo);\n  } else if (typeof keysInfo === 'string') {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    // support old method\n    // eslint-disable-line\n    let [scope, method] = args;\n    if (typeof scope === 'function') {\n      method = scope;\n      scope = '';\n    }\n    eachUnbind({\n      key: keysInfo,\n      scope,\n      method,\n      splitKey: '+'\n    });\n  }\n}\n\n/** Unbind hotkeys for a specific scope */\nconst eachUnbind = _ref3 => {\n  let {\n    key,\n    scope,\n    method,\n    splitKey = '+'\n  } = _ref3;\n  const multipleKeys = getKeys(key);\n  multipleKeys.forEach(originKey => {\n    const unbindKeys = originKey.split(splitKey);\n    const len = unbindKeys.length;\n    const lastKey = unbindKeys[len - 1];\n    const keyCode = lastKey === '*' ? '*' : code(lastKey);\n    if (!_handlers[keyCode]) return;\n    // If scope is not provided, get the current scope\n    if (!scope) scope = getScope();\n    const mods = len > 1 ? getMods(_modifier, unbindKeys) : [];\n    const unbindElements = [];\n    _handlers[keyCode] = _handlers[keyCode].filter(record => {\n      // Check if the method matches; if method is provided, must be equal to unbind\n      const isMatchingMethod = method ? record.method === method : true;\n      const isUnbind = isMatchingMethod && record.scope === scope && compareArray(record.mods, mods);\n      if (isUnbind) unbindElements.push(record.element);\n      return !isUnbind;\n    });\n    unbindElements.forEach(element => removeKeyEvent(element));\n  });\n};\n\n/** Handle the callback function for the corresponding hotkey */\nfunction eventHandler(event, handler, scope, element) {\n  if (handler.element !== element) {\n    return;\n  }\n  let modifiersMatch;\n\n  // Check if it is within the current scope\n  if (handler.scope === scope || handler.scope === 'all') {\n    // Check whether modifier keys match (returns true if they do)\n    modifiersMatch = handler.mods.length > 0;\n    for (const y in _mods) {\n      if (Object.prototype.hasOwnProperty.call(_mods, y)) {\n        if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {\n          modifiersMatch = false;\n        }\n      }\n    }\n\n    // Call the handler function; ignore if it's only a modifier key\n    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === '*') {\n      handler.keys = [];\n      handler.keys = handler.keys.concat(_downKeys);\n      if (handler.method(event, handler) === false) {\n        if (event.preventDefault) event.preventDefault();else event.returnValue = false;\n        if (event.stopPropagation) event.stopPropagation();\n        if (event.cancelBubble) event.cancelBubble = true;\n      }\n    }\n  }\n}\n\n/** Handle the keydown event */\nfunction dispatch(event, element) {\n  const asterisk = _handlers['*'];\n  let key = event.keyCode || event.which || event.charCode;\n  // Ensure that when capturing keystrokes in modern browsers,\n  // uppercase and lowercase letters (such as R and r) return the same key value.\n  // https://github.com/jaywcjlove/hotkeys-js/pull/514\n  // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n  // CapsLock key\n  // There's an issue where `keydown` and `keyup` events are not triggered after CapsLock is enabled to activate uppercase.\n  if (event.key && event.key.toLowerCase() === 'capslock') {\n    return;\n  }\n  // Form control filter: by default, shortcut keys are not triggered in form elements\n  if (!hotkeys.filter.call(this, event)) return;\n\n  // In Gecko (Firefox), the command key code is 224; unify it with WebKit (Chrome)\n  // In WebKit, left and right command keys have different codes\n  if (key === 93 || key === 224) key = 91;\n\n  /**\n   * Collect bound keys\n   * If an Input Method Editor is processing key input and the event is keydown, return 229.\n   * https://stackoverflow.com/questions/25043934/is-it-ok-to-ignore-keydown-events-with-keycode-229\n   * http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html\n   */\n  if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);\n  /**\n   * Jest test cases are required.\n   * ===============================\n   */\n  ['metaKey', 'ctrlKey', 'altKey', 'shiftKey'].forEach(keyName => {\n    const keyNum = modifierMap[keyName];\n    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {\n      _downKeys.push(keyNum);\n    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {\n      _downKeys.splice(_downKeys.indexOf(keyNum), 1);\n    } else if (keyName === 'metaKey' && event[keyName]) {\n      // If the command key is pressed, clear all non-modifier keys except the current event key.\n      // This is because keyup for non-modifier keys will NEVER be triggered when command is pressed.\n      // This is a known browser limitation.\n      _downKeys = _downKeys.filter(k => k in modifierMap || k === key);\n    }\n  });\n  /**\n   * -------------------------------\n   */\n  if (key in _mods) {\n    _mods[key] = true;\n    // Register special modifier keys to the `hotkeys` object\n    for (const k in _modifier) {\n      if (Object.prototype.hasOwnProperty.call(_modifier, k)) {\n        const eventKey = modifierMap[_modifier[k]];\n        hotkeys[k] = event[eventKey];\n      }\n    }\n    if (!asterisk) return;\n  }\n\n  // Bind the modifier keys in modifierMap to the event\n  for (const e in _mods) {\n    if (Object.prototype.hasOwnProperty.call(_mods, e)) {\n      _mods[e] = event[modifierMap[e]];\n    }\n  }\n  /**\n   * https://github.com/jaywcjlove/hotkeys/pull/129\n   * This solves the issue in Firefox on Windows where hotkeys corresponding to special characters would not trigger.\n   * An example of this is ctrl+alt+m on a Swedish keyboard which is used to type μ.\n   * Browser support: https://caniuse.com/#feat=keyboardevent-getmodifierstate\n   */\n  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState('AltGraph')) {\n    if (_downKeys.indexOf(17) === -1) {\n      _downKeys.push(17);\n    }\n    if (_downKeys.indexOf(18) === -1) {\n      _downKeys.push(18);\n    }\n    _mods[17] = true;\n    _mods[18] = true;\n  }\n\n  // Get the current scope (defaults to 'all')\n  const scope = getScope();\n  // Handle any hotkeys registered as '*'\n  if (asterisk) {\n    for (let i = 0; i < asterisk.length; i++) {\n      if (asterisk[i].scope === scope && (event.type === 'keydown' && asterisk[i].keydown || event.type === 'keyup' && asterisk[i].keyup)) {\n        eventHandler(event, asterisk[i], scope, element);\n      }\n    }\n  }\n  // If the key is not registered, return\n  if (!(key in _handlers)) return;\n  const handlerKey = _handlers[key];\n  const keyLen = handlerKey.length;\n  for (let i = 0; i < keyLen; i++) {\n    if (event.type === 'keydown' && handlerKey[i].keydown || event.type === 'keyup' && handlerKey[i].keyup) {\n      if (handlerKey[i].key) {\n        const record = handlerKey[i];\n        const {\n          splitKey\n        } = record;\n        const keyShortcut = record.key.split(splitKey);\n        const _downKeysCurrent = []; // Store the current key codes\n        for (let a = 0; a < keyShortcut.length; a++) {\n          _downKeysCurrent.push(code(keyShortcut[a]));\n        }\n        if (_downKeysCurrent.sort().join('') === _downKeys.sort().join('')) {\n          // Match found, call the handler\n          eventHandler(event, record, scope, element);\n        }\n      }\n    }\n  }\n}\nfunction hotkeys(key, option, method) {\n  _downKeys = [];\n  /** List of hotkeys to handle */\n  const keys = getKeys(key);\n  let mods = [];\n  /** Default scope is 'all', meaning effective in all scopes */\n  let scope = 'all';\n  /** Element to which the hotkey events are bound */\n  let element = document;\n  let i = 0;\n  let keyup = false;\n  let keydown = true;\n  let splitKey = '+';\n  let capture = false;\n  /** Allow only a single callback */\n  let single = false;\n\n  // Determine if the second argument is a function (no options provided)\n  if (method === undefined && typeof option === 'function') {\n    method = option;\n  }\n\n  // Parse options object\n  if (Object.prototype.toString.call(option) === '[object Object]') {\n    if (option.scope) scope = option.scope; // Set scope\n    if (option.element) element = option.element; // Set binding element\n    if (option.keyup) keyup = option.keyup;\n    if (option.keydown !== undefined) keydown = option.keydown;\n    if (option.capture !== undefined) capture = option.capture;\n    if (typeof option.splitKey === 'string') splitKey = option.splitKey;\n    if (option.single === true) single = true;\n  }\n  if (typeof option === 'string') scope = option;\n\n  // If only one callback is allowed, unbind the existing one first\n  if (single) unbind(key, scope);\n\n  // Handle each hotkey\n  for (; i < keys.length; i++) {\n    key = keys[i].split(splitKey); // Split into individual keys\n    mods = [];\n\n    // If it's a combination, extract modifier keys\n    if (key.length > 1) mods = getMods(_modifier, key);\n\n    // Convert non-modifier key to key code\n    key = key[key.length - 1];\n    key = key === '*' ? '*' : code(key); // '*' means match all hotkeys\n\n    // Initialize handler array if this key has no handlers yet\n    if (!(key in _handlers)) _handlers[key] = [];\n    _handlers[key].push({\n      keyup,\n      keydown,\n      scope,\n      mods,\n      shortcut: keys[i],\n      method,\n      key: keys[i],\n      splitKey,\n      element\n    });\n  }\n  // Register hotkey event listeners on the global document\n  if (typeof element !== 'undefined' && window) {\n    if (!elementEventMap.has(element)) {\n      const keydownListener = function () {\n        let event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.event;\n        return dispatch(event, element);\n      };\n      const keyupListenr = function () {\n        let event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.event;\n        dispatch(event, element);\n        clearModifier(event);\n      };\n      elementEventMap.set(element, {\n        keydownListener,\n        keyupListenr,\n        capture\n      });\n      addEvent(element, 'keydown', keydownListener, capture);\n      addEvent(element, 'keyup', keyupListenr, capture);\n    }\n    // Register focus event listener once to clear pressed keys on window focus\n    if (!winListendFocus) {\n      const listener = () => {\n        _downKeys = [];\n      };\n      winListendFocus = {\n        listener,\n        capture\n      };\n      addEvent(window, 'focus', listener, capture);\n    }\n  }\n}\nfunction trigger(shortcut) {\n  let scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';\n  Object.keys(_handlers).forEach(key => {\n    const dataList = _handlers[key].filter(item => item.scope === scope && item.shortcut === shortcut);\n    dataList.forEach(data => {\n      if (data && data.method) {\n        data.method();\n      }\n    });\n  });\n}\n\n/** Clean up event listeners. After unbinding, check whether the element still has any hotkeys bound. If not, remove its event listeners. */\nfunction removeKeyEvent(element) {\n  const values = Object.values(_handlers).flat();\n  const findindex = values.findIndex(_ref4 => {\n    let {\n      element: el\n    } = _ref4;\n    return el === element;\n  });\n  if (findindex < 0) {\n    const {\n      keydownListener,\n      keyupListenr,\n      capture\n    } = elementEventMap.get(element) || {};\n    if (keydownListener && keyupListenr) {\n      removeEvent(element, 'keyup', keyupListenr, capture);\n      removeEvent(element, 'keydown', keydownListener, capture);\n      elementEventMap.delete(element);\n    }\n  }\n  if (values.length <= 0 || elementEventMap.size <= 0) {\n    // Remove all event listeners from all elements\n    const eventKeys = Object.keys(elementEventMap);\n    eventKeys.forEach(el => {\n      const {\n        keydownListener,\n        keyupListenr,\n        capture\n      } = elementEventMap.get(el) || {};\n      if (keydownListener && keyupListenr) {\n        removeEvent(el, 'keyup', keyupListenr, capture);\n        removeEvent(el, 'keydown', keydownListener, capture);\n        elementEventMap.delete(el);\n      }\n    });\n    // Clear the elementEventMap\n    elementEventMap.clear();\n    // Clear all handlers\n    Object.keys(_handlers).forEach(key => delete _handlers[key]);\n    // Remove the global window focus event listener\n    if (winListendFocus) {\n      const {\n        listener,\n        capture\n      } = winListendFocus;\n      removeEvent(window, 'focus', listener, capture);\n      winListendFocus = null;\n    }\n  }\n}\nconst _api = {\n  getPressedKeyString,\n  setScope,\n  getScope,\n  deleteScope,\n  getPressedKeyCodes,\n  getAllKeyCodes,\n  isPressed,\n  filter,\n  trigger,\n  unbind,\n  keyMap: _keyMap,\n  modifier: _modifier,\n  modifierMap\n};\nfor (const a in _api) {\n  if (Object.prototype.hasOwnProperty.call(_api, a)) {\n    hotkeys[a] = _api[a];\n  }\n}\nif (typeof window !== 'undefined') {\n  const _hotkeys = window.hotkeys;\n  hotkeys.noConflict = deep => {\n    if (deep && window.hotkeys === hotkeys) {\n      window.hotkeys = _hotkeys;\n    }\n    return hotkeys;\n  };\n  window.hotkeys = hotkeys;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaG90a2V5cy1qcy9kaXN0L2hvdGtleXMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQSxTQUFTLFdBQVc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEIiLCJzb3VyY2VzIjpbIi9ob21lL2ZhaG15L0RvY3VtZW50cy9Qcm9qZWN0L3Byb2plY3Qgd2ViL2Fic2Vuc2kvbm9kZV9tb2R1bGVzL2hvdGtleXMtanMvZGlzdC9ob3RrZXlzLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiohIFxuICogaG90a2V5cy1qcyB2My4xMy4xNSBcbiAqIEEgc2ltcGxlIG1pY3JvLWxpYnJhcnkgZm9yIGRlZmluaW5nIGFuZCBkaXNwYXRjaGluZyBrZXlib2FyZCBzaG9ydGN1dHMuIEl0IGhhcyBubyBkZXBlbmRlbmNpZXMuIFxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjUga2Vubnkgd29uZyA8d293b2hvb0BxcS5jb20+IFxuICogaHR0cHM6Ly9naXRodWIuY29tL2pheXdjamxvdmUvaG90a2V5cy1qcy5naXQgXG4gKiBcbiAqIEB3ZWJzaXRlOiBodHRwczovL2pheXdjamxvdmUuZ2l0aHViLmlvL2hvdGtleXMtanNcbiBcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBcbiAqL1xuXG5jb25zdCBpc2ZmID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpID4gMCA6IGZhbHNlO1xuXG4vKiogQmluZCBldmVudCAqL1xuZnVuY3Rpb24gYWRkRXZlbnQob2JqZWN0LCBldmVudCwgbWV0aG9kLCB1c2VDYXB0dXJlKSB7XG4gIGlmIChvYmplY3QuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIG9iamVjdC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBtZXRob2QsIHVzZUNhcHR1cmUpO1xuICB9IGVsc2UgaWYgKG9iamVjdC5hdHRhY2hFdmVudCkge1xuICAgIG9iamVjdC5hdHRhY2hFdmVudChcIm9uXCIuY29uY2F0KGV2ZW50KSwgbWV0aG9kKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlRXZlbnQob2JqZWN0LCBldmVudCwgbWV0aG9kLCB1c2VDYXB0dXJlKSB7XG4gIGlmIChvYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIG9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBtZXRob2QsIHVzZUNhcHR1cmUpO1xuICB9IGVsc2UgaWYgKG9iamVjdC5kZXRhY2hFdmVudCkge1xuICAgIG9iamVjdC5kZXRhY2hFdmVudChcIm9uXCIuY29uY2F0KGV2ZW50KSwgbWV0aG9kKTtcbiAgfVxufVxuXG4vKiogQ29udmVydCBtb2RpZmllciBrZXlzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcga2V5IGNvZGVzICovXG5mdW5jdGlvbiBnZXRNb2RzKG1vZGlmaWVyLCBrZXkpIHtcbiAgY29uc3QgbW9kcyA9IGtleS5zbGljZSgwLCBrZXkubGVuZ3RoIC0gMSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kcy5sZW5ndGg7IGkrKykgbW9kc1tpXSA9IG1vZGlmaWVyW21vZHNbaV0udG9Mb3dlckNhc2UoKV07XG4gIHJldHVybiBtb2RzO1xufVxuXG4vKiogUHJvY2VzcyB0aGUgaW5wdXQga2V5IHN0cmluZyBhbmQgY29udmVydCBpdCB0byBhbiBhcnJheSAqL1xuZnVuY3Rpb24gZ2V0S2V5cyhrZXkpIHtcbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSBrZXkgPSAnJztcbiAga2V5ID0ga2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7IC8vIE1hdGNoIGFueSB3aGl0ZXNwYWNlIGNoYXJhY3RlciwgaW5jbHVkaW5nIHNwYWNlcywgdGFicywgZm9ybSBmZWVkcywgZXRjLlxuICBjb25zdCBrZXlzID0ga2V5LnNwbGl0KCcsJyk7IC8vIEFsbG93IG11bHRpcGxlIHNob3J0Y3V0cyBzZXBhcmF0ZWQgYnkgJywnXG4gIGxldCBpbmRleCA9IGtleXMubGFzdEluZGV4T2YoJycpO1xuXG4gIC8vIFNob3J0Y3V0IG1heSBpbmNsdWRlICcsJyDigJQgc3BlY2lhbCBoYW5kbGluZyBuZWVkZWRcbiAgZm9yICg7IGluZGV4ID49IDA7KSB7XG4gICAga2V5c1tpbmRleCAtIDFdICs9ICcsJztcbiAgICBrZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgaW5kZXggPSBrZXlzLmxhc3RJbmRleE9mKCcnKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuLyoqIENvbXBhcmUgYXJyYXlzIG9mIG1vZGlmaWVyIGtleXMgKi9cbmZ1bmN0aW9uIGNvbXBhcmVBcnJheShhMSwgYTIpIHtcbiAgY29uc3QgYXJyMSA9IGExLmxlbmd0aCA+PSBhMi5sZW5ndGggPyBhMSA6IGEyO1xuICBjb25zdCBhcnIyID0gYTEubGVuZ3RoID49IGEyLmxlbmd0aCA/IGEyIDogYTE7XG4gIGxldCBpc0luZGV4ID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycjIuaW5kZXhPZihhcnIxW2ldKSA9PT0gLTEpIGlzSW5kZXggPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNJbmRleDtcbn1cblxuLy8gU3BlY2lhbCBLZXlzXG5jb25zdCBfa2V5TWFwID0ge1xuICBiYWNrc3BhY2U6IDgsXG4gICfijKsnOiA4LFxuICB0YWI6IDksXG4gIGNsZWFyOiAxMixcbiAgZW50ZXI6IDEzLFxuICAn4oapJzogMTMsXG4gIHJldHVybjogMTMsXG4gIGVzYzogMjcsXG4gIGVzY2FwZTogMjcsXG4gIHNwYWNlOiAzMixcbiAgbGVmdDogMzcsXG4gIHVwOiAzOCxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgLy8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby91aWV2ZW50cy8jZXZlbnRzLWtleWJvYXJkLWtleS1sb2NhdGlvblxuICBhcnJvd3VwOiAzOCxcbiAgYXJyb3dkb3duOiA0MCxcbiAgYXJyb3dsZWZ0OiAzNyxcbiAgYXJyb3dyaWdodDogMzksXG4gIGRlbDogNDYsXG4gIGRlbGV0ZTogNDYsXG4gIGluczogNDUsXG4gIGluc2VydDogNDUsXG4gIGhvbWU6IDM2LFxuICBlbmQ6IDM1LFxuICBwYWdldXA6IDMzLFxuICBwYWdlZG93bjogMzQsXG4gIGNhcHNsb2NrOiAyMCxcbiAgbnVtXzA6IDk2LFxuICBudW1fMTogOTcsXG4gIG51bV8yOiA5OCxcbiAgbnVtXzM6IDk5LFxuICBudW1fNDogMTAwLFxuICBudW1fNTogMTAxLFxuICBudW1fNjogMTAyLFxuICBudW1fNzogMTAzLFxuICBudW1fODogMTA0LFxuICBudW1fOTogMTA1LFxuICBudW1fbXVsdGlwbHk6IDEwNixcbiAgbnVtX2FkZDogMTA3LFxuICBudW1fZW50ZXI6IDEwOCxcbiAgbnVtX3N1YnRyYWN0OiAxMDksXG4gIG51bV9kZWNpbWFsOiAxMTAsXG4gIG51bV9kaXZpZGU6IDExMSxcbiAgJ+KHqic6IDIwLFxuICAnLCc6IDE4OCxcbiAgJy4nOiAxOTAsXG4gICcvJzogMTkxLFxuICAnYCc6IDE5MixcbiAgJy0nOiBpc2ZmID8gMTczIDogMTg5LFxuICAnPSc6IGlzZmYgPyA2MSA6IDE4NyxcbiAgJzsnOiBpc2ZmID8gNTkgOiAxODYsXG4gICdcXCcnOiAyMjIsXG4gICd7JzogMjE5LFxuICAnfSc6IDIyMSxcbiAgJ1snOiAyMTksXG4gICddJzogMjIxLFxuICAnXFxcXCc6IDIyMFxufTtcblxuLy8gTW9kaWZpZXIgS2V5c1xuY29uc3QgX21vZGlmaWVyID0ge1xuICAvLyBzaGlmdEtleVxuICAn4oenJzogMTYsXG4gIHNoaWZ0OiAxNixcbiAgLy8gYWx0S2V5XG4gICfijKUnOiAxOCxcbiAgYWx0OiAxOCxcbiAgb3B0aW9uOiAxOCxcbiAgLy8gY3RybEtleVxuICAn4oyDJzogMTcsXG4gIGN0cmw6IDE3LFxuICBjb250cm9sOiAxNyxcbiAgLy8gbWV0YUtleVxuICAn4oyYJzogOTEsXG4gIGNtZDogOTEsXG4gIG1ldGE6IDkxLFxuICBjb21tYW5kOiA5MVxufTtcbmNvbnN0IG1vZGlmaWVyTWFwID0ge1xuICAxNjogJ3NoaWZ0S2V5JyxcbiAgMTg6ICdhbHRLZXknLFxuICAxNzogJ2N0cmxLZXknLFxuICA5MTogJ21ldGFLZXknLFxuICBzaGlmdEtleTogMTYsXG4gIGN0cmxLZXk6IDE3LFxuICBhbHRLZXk6IDE4LFxuICBtZXRhS2V5OiA5MVxufTtcbmNvbnN0IF9tb2RzID0ge1xuICAxNjogZmFsc2UsXG4gIDE4OiBmYWxzZSxcbiAgMTc6IGZhbHNlLFxuICA5MTogZmFsc2Vcbn07XG5jb25zdCBfaGFuZGxlcnMgPSB7fTtcblxuLy8gRjF+RjEyIHNwZWNpYWwga2V5XG5mb3IgKGxldCBrID0gMTsgayA8IDIwOyBrKyspIHtcbiAgX2tleU1hcFtcImZcIi5jb25jYXQoayldID0gMTExICsgaztcbn1cblxuLyoqIFJlY29yZCB0aGUgcHJlc3NlZCBrZXlzICovXG5sZXQgX2Rvd25LZXlzID0gW107XG4vKiogV2hldGhlciB0aGUgd2luZG93IGhhcyBhbHJlYWR5IGxpc3RlbmVkIHRvIHRoZSBmb2N1cyBldmVudCAqL1xubGV0IHdpbkxpc3RlbmRGb2N1cyA9IG51bGw7XG4vKiogRGVmYXVsdCBob3RrZXkgc2NvcGUgKi9cbmxldCBfc2NvcGUgPSAnYWxsJztcbi8qKiBNYXAgdG8gcmVjb3JkIGVsZW1lbnRzIHdpdGggYm91bmQgZXZlbnRzICovXG5jb25zdCBlbGVtZW50RXZlbnRNYXAgPSBuZXcgTWFwKCk7XG5cbi8qKiBSZXR1cm4ga2V5IGNvZGUgKi9cbmNvbnN0IGNvZGUgPSB4ID0+IF9rZXlNYXBbeC50b0xvd2VyQ2FzZSgpXSB8fCBfbW9kaWZpZXJbeC50b0xvd2VyQ2FzZSgpXSB8fCB4LnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcbmNvbnN0IGdldEtleSA9IHggPT4gT2JqZWN0LmtleXMoX2tleU1hcCkuZmluZChrID0+IF9rZXlNYXBba10gPT09IHgpO1xuY29uc3QgZ2V0TW9kaWZpZXIgPSB4ID0+IE9iamVjdC5rZXlzKF9tb2RpZmllcikuZmluZChrID0+IF9tb2RpZmllcltrXSA9PT0geCk7XG5cbi8qKiBTZXQgb3IgZ2V0IHRoZSBjdXJyZW50IHNjb3BlIChkZWZhdWx0cyB0byAnYWxsJykgKi9cbmZ1bmN0aW9uIHNldFNjb3BlKHNjb3BlKSB7XG4gIF9zY29wZSA9IHNjb3BlIHx8ICdhbGwnO1xufVxuLyoqIEdldCB0aGUgY3VycmVudCBzY29wZSAqL1xuZnVuY3Rpb24gZ2V0U2NvcGUoKSB7XG4gIHJldHVybiBfc2NvcGUgfHwgJ2FsbCc7XG59XG4vKiogR2V0IHRoZSBrZXkgY29kZXMgb2YgdGhlIGN1cnJlbnRseSBwcmVzc2VkIGtleXMgKi9cbmZ1bmN0aW9uIGdldFByZXNzZWRLZXlDb2RlcygpIHtcbiAgcmV0dXJuIF9kb3duS2V5cy5zbGljZSgwKTtcbn1cbmZ1bmN0aW9uIGdldFByZXNzZWRLZXlTdHJpbmcoKSB7XG4gIHJldHVybiBfZG93bktleXMubWFwKGMgPT4gZ2V0S2V5KGMpIHx8IGdldE1vZGlmaWVyKGMpIHx8IFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xufVxuZnVuY3Rpb24gZ2V0QWxsS2V5Q29kZXMoKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBPYmplY3Qua2V5cyhfaGFuZGxlcnMpLmZvckVhY2goayA9PiB7XG4gICAgX2hhbmRsZXJzW2tdLmZvckVhY2goX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBrZXksXG4gICAgICAgIHNjb3BlLFxuICAgICAgICBtb2RzLFxuICAgICAgICBzaG9ydGN1dFxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIHNjb3BlLFxuICAgICAgICBzaG9ydGN1dCxcbiAgICAgICAgbW9kcyxcbiAgICAgICAga2V5czoga2V5LnNwbGl0KCcrJykubWFwKHYgPT4gY29kZSh2KSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIGhvdGtleSBpcyBlZmZlY3RpdmUgb25seSB3aGVuIGZpbHRlciByZXR1cm4gdHJ1ZSAqL1xuZnVuY3Rpb24gZmlsdGVyKGV2ZW50KSB7XG4gIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuICBjb25zdCB7XG4gICAgdGFnTmFtZVxuICB9ID0gdGFyZ2V0O1xuICBsZXQgZmxhZyA9IHRydWU7XG4gIGNvbnN0IGlzSW5wdXQgPSB0YWdOYW1lID09PSAnSU5QVVQnICYmICFbJ2NoZWNrYm94JywgJ3JhZGlvJywgJ3JhbmdlJywgJ2J1dHRvbicsICdmaWxlJywgJ3Jlc2V0JywgJ3N1Ym1pdCcsICdjb2xvciddLmluY2x1ZGVzKHRhcmdldC50eXBlKTtcbiAgLy8gaWdub3JlOiBpc0NvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnLCA8aW5wdXQ+IGFuZCA8dGV4dGFyZWE+IHdoZW4gcmVhZE9ubHkgc3RhdGUgaXMgZmFsc2UsIDxzZWxlY3Q+XG4gIGlmICh0YXJnZXQuaXNDb250ZW50RWRpdGFibGUgfHwgKGlzSW5wdXQgfHwgdGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyB8fCB0YWdOYW1lID09PSAnU0VMRUNUJykgJiYgIXRhcmdldC5yZWFkT25seSkge1xuICAgIGZsYWcgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gZmxhZztcbn1cblxuLyoqIERldGVybWluZSB3aGV0aGVyIHRoZSBwcmVzc2VkIGtleSBtYXRjaGVzIGEgc3BlY2lmaWMga2V5LCByZXR1cm5zIHRydWUgb3IgZmFsc2UgKi9cbmZ1bmN0aW9uIGlzUHJlc3NlZChrZXlDb2RlKSB7XG4gIGlmICh0eXBlb2Yga2V5Q29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICBrZXlDb2RlID0gY29kZShrZXlDb2RlKTsgLy8gQ29udmVydCB0byBrZXkgY29kZVxuICB9XG4gIHJldHVybiBfZG93bktleXMuaW5kZXhPZihrZXlDb2RlKSAhPT0gLTE7XG59XG5cbi8qKiBMb29wIHRocm91Z2ggYW5kIGRlbGV0ZSBhbGwgaGFuZGxlcnMgd2l0aCB0aGUgc3BlY2lmaWVkIHNjb3BlICovXG5mdW5jdGlvbiBkZWxldGVTY29wZShzY29wZSwgbmV3U2NvcGUpIHtcbiAgbGV0IGhhbmRsZXJzO1xuICBsZXQgaTtcblxuICAvLyBJZiBubyBzY29wZSBpcyBzcGVjaWZpZWQsIGdldCB0aGUgY3VycmVudCBzY29wZVxuICBpZiAoIXNjb3BlKSBzY29wZSA9IGdldFNjb3BlKCk7XG4gIGZvciAoY29uc3Qga2V5IGluIF9oYW5kbGVycykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2hhbmRsZXJzLCBrZXkpKSB7XG4gICAgICBoYW5kbGVycyA9IF9oYW5kbGVyc1trZXldO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDspIHtcbiAgICAgICAgaWYgKGhhbmRsZXJzW2ldLnNjb3BlID09PSBzY29wZSkge1xuICAgICAgICAgIGNvbnN0IGRlbGV0ZUl0ZW1zID0gaGFuZGxlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGRlbGV0ZUl0ZW1zLmZvckVhY2goX3JlZjIgPT4ge1xuICAgICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgICAgZWxlbWVudFxuICAgICAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUtleUV2ZW50KGVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBjdXJyZW50IHNjb3BlIGhhcyBiZWVuIGRlbGV0ZWQsIHJlc2V0IHRoZSBzY29wZSB0byAnYWxsJ1xuICBpZiAoZ2V0U2NvcGUoKSA9PT0gc2NvcGUpIHNldFNjb3BlKG5ld1Njb3BlIHx8ICdhbGwnKTtcbn1cblxuLyoqIENsZWFyIG1vZGlmaWVyIGtleXMgKi9cbmZ1bmN0aW9uIGNsZWFyTW9kaWZpZXIoZXZlbnQpIHtcbiAgbGV0IGtleSA9IGV2ZW50LmtleUNvZGUgfHwgZXZlbnQud2hpY2ggfHwgZXZlbnQuY2hhckNvZGU7XG4gIGlmIChldmVudC5rZXkgJiYgZXZlbnQua2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjYXBzbG9jaycpIHtcbiAgICAvLyBFbnN1cmUgdGhhdCB3aGVuIGNhcHR1cmluZyBrZXlzdHJva2VzIGluIG1vZGVybiBicm93c2VycyxcbiAgICAvLyB1cHBlcmNhc2UgYW5kIGxvd2VyY2FzZSBsZXR0ZXJzIChzdWNoIGFzIFIgYW5kIHIpIHJldHVybiB0aGUgc2FtZSBrZXkgdmFsdWUuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pheXdjamxvdmUvaG90a2V5cy1qcy9wdWxsLzUxNFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleVxuICAgIGtleSA9IGNvZGUoZXZlbnQua2V5KTtcbiAgfVxuICBjb25zdCBpID0gX2Rvd25LZXlzLmluZGV4T2Yoa2V5KTtcblxuICAvLyBSZW1vdmUgdGhlIHByZXNzZWQga2V5IGZyb20gdGhlIGxpc3RcbiAgaWYgKGkgPj0gMCkge1xuICAgIF9kb3duS2V5cy5zcGxpY2UoaSwgMSk7XG4gIH1cbiAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgdGhlIGNvbW1hbmQga2V5OiBmaXggdGhlIGlzc3VlIHdoZXJlIGtleXVwIG9ubHkgdHJpZ2dlcnMgb25jZSBmb3IgY29tbWFuZCBjb21ib3NcbiAgaWYgKGV2ZW50LmtleSAmJiBldmVudC5rZXkudG9Mb3dlckNhc2UoKSA9PT0gJ21ldGEnKSB7XG4gICAgX2Rvd25LZXlzLnNwbGljZSgwLCBfZG93bktleXMubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIENsZWFyIG1vZGlmaWVyIGtleXM6IHNoaWZ0S2V5LCBhbHRLZXksIGN0cmxLZXksIChjb21tYW5kIHx8IG1ldGFLZXkpXG4gIGlmIChrZXkgPT09IDkzIHx8IGtleSA9PT0gMjI0KSBrZXkgPSA5MTtcbiAgaWYgKGtleSBpbiBfbW9kcykge1xuICAgIF9tb2RzW2tleV0gPSBmYWxzZTtcblxuICAgIC8vIFJlc2V0IHRoZSBtb2RpZmllciBrZXkgc3RhdHVzIHRvIGZhbHNlXG4gICAgZm9yIChjb25zdCBrIGluIF9tb2RpZmllcikgaWYgKF9tb2RpZmllcltrXSA9PT0ga2V5KSBob3RrZXlzW2tdID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHVuYmluZChrZXlzSW5mbykge1xuICAvLyB1bmJpbmQoKSwgdW5iaW5kIGFsbCBrZXlzXG4gIGlmICh0eXBlb2Yga2V5c0luZm8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgT2JqZWN0LmtleXMoX2hhbmRsZXJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBBcnJheS5pc0FycmF5KF9oYW5kbGVyc1trZXldKSAmJiBfaGFuZGxlcnNba2V5XS5mb3JFYWNoKGluZm8gPT4gZWFjaFVuYmluZChpbmZvKSk7XG4gICAgICBkZWxldGUgX2hhbmRsZXJzW2tleV07XG4gICAgfSk7XG4gICAgcmVtb3ZlS2V5RXZlbnQobnVsbCk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShrZXlzSW5mbykpIHtcbiAgICAvLyBzdXBwb3J0IGxpa2UgOiB1bmJpbmQoW3trZXk6ICdjdHJsK2EnLCBzY29wZTogJ3MxJ30sIHtrZXk6ICdjdHJsLWEnLCBzY29wZTogJ3MyJywgc3BsaXRLZXk6ICctJ31dKVxuICAgIGtleXNJbmZvLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICBpZiAoaW5mby5rZXkpIGVhY2hVbmJpbmQoaW5mbyk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGtleXNJbmZvID09PSAnb2JqZWN0Jykge1xuICAgIC8vIHN1cHBvcnQgbGlrZSB1bmJpbmQoe2tleTogJ2N0cmwrYSwgY3RybCtiJywgc2NvcGU6J2FiYyd9KVxuICAgIGlmIChrZXlzSW5mby5rZXkpIGVhY2hVbmJpbmQoa2V5c0luZm8pO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBrZXlzSW5mbyA9PT0gJ3N0cmluZycpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgLy8gc3VwcG9ydCBvbGQgbWV0aG9kXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGxldCBbc2NvcGUsIG1ldGhvZF0gPSBhcmdzO1xuICAgIGlmICh0eXBlb2Ygc2NvcGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1ldGhvZCA9IHNjb3BlO1xuICAgICAgc2NvcGUgPSAnJztcbiAgICB9XG4gICAgZWFjaFVuYmluZCh7XG4gICAgICBrZXk6IGtleXNJbmZvLFxuICAgICAgc2NvcGUsXG4gICAgICBtZXRob2QsXG4gICAgICBzcGxpdEtleTogJysnXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqIFVuYmluZCBob3RrZXlzIGZvciBhIHNwZWNpZmljIHNjb3BlICovXG5jb25zdCBlYWNoVW5iaW5kID0gX3JlZjMgPT4ge1xuICBsZXQge1xuICAgIGtleSxcbiAgICBzY29wZSxcbiAgICBtZXRob2QsXG4gICAgc3BsaXRLZXkgPSAnKydcbiAgfSA9IF9yZWYzO1xuICBjb25zdCBtdWx0aXBsZUtleXMgPSBnZXRLZXlzKGtleSk7XG4gIG11bHRpcGxlS2V5cy5mb3JFYWNoKG9yaWdpbktleSA9PiB7XG4gICAgY29uc3QgdW5iaW5kS2V5cyA9IG9yaWdpbktleS5zcGxpdChzcGxpdEtleSk7XG4gICAgY29uc3QgbGVuID0gdW5iaW5kS2V5cy5sZW5ndGg7XG4gICAgY29uc3QgbGFzdEtleSA9IHVuYmluZEtleXNbbGVuIC0gMV07XG4gICAgY29uc3Qga2V5Q29kZSA9IGxhc3RLZXkgPT09ICcqJyA/ICcqJyA6IGNvZGUobGFzdEtleSk7XG4gICAgaWYgKCFfaGFuZGxlcnNba2V5Q29kZV0pIHJldHVybjtcbiAgICAvLyBJZiBzY29wZSBpcyBub3QgcHJvdmlkZWQsIGdldCB0aGUgY3VycmVudCBzY29wZVxuICAgIGlmICghc2NvcGUpIHNjb3BlID0gZ2V0U2NvcGUoKTtcbiAgICBjb25zdCBtb2RzID0gbGVuID4gMSA/IGdldE1vZHMoX21vZGlmaWVyLCB1bmJpbmRLZXlzKSA6IFtdO1xuICAgIGNvbnN0IHVuYmluZEVsZW1lbnRzID0gW107XG4gICAgX2hhbmRsZXJzW2tleUNvZGVdID0gX2hhbmRsZXJzW2tleUNvZGVdLmZpbHRlcihyZWNvcmQgPT4ge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG1ldGhvZCBtYXRjaGVzOyBpZiBtZXRob2QgaXMgcHJvdmlkZWQsIG11c3QgYmUgZXF1YWwgdG8gdW5iaW5kXG4gICAgICBjb25zdCBpc01hdGNoaW5nTWV0aG9kID0gbWV0aG9kID8gcmVjb3JkLm1ldGhvZCA9PT0gbWV0aG9kIDogdHJ1ZTtcbiAgICAgIGNvbnN0IGlzVW5iaW5kID0gaXNNYXRjaGluZ01ldGhvZCAmJiByZWNvcmQuc2NvcGUgPT09IHNjb3BlICYmIGNvbXBhcmVBcnJheShyZWNvcmQubW9kcywgbW9kcyk7XG4gICAgICBpZiAoaXNVbmJpbmQpIHVuYmluZEVsZW1lbnRzLnB1c2gocmVjb3JkLmVsZW1lbnQpO1xuICAgICAgcmV0dXJuICFpc1VuYmluZDtcbiAgICB9KTtcbiAgICB1bmJpbmRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4gcmVtb3ZlS2V5RXZlbnQoZWxlbWVudCkpO1xuICB9KTtcbn07XG5cbi8qKiBIYW5kbGUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgY29ycmVzcG9uZGluZyBob3RrZXkgKi9cbmZ1bmN0aW9uIGV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlciwgc2NvcGUsIGVsZW1lbnQpIHtcbiAgaWYgKGhhbmRsZXIuZWxlbWVudCAhPT0gZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbW9kaWZpZXJzTWF0Y2g7XG5cbiAgLy8gQ2hlY2sgaWYgaXQgaXMgd2l0aGluIHRoZSBjdXJyZW50IHNjb3BlXG4gIGlmIChoYW5kbGVyLnNjb3BlID09PSBzY29wZSB8fCBoYW5kbGVyLnNjb3BlID09PSAnYWxsJykge1xuICAgIC8vIENoZWNrIHdoZXRoZXIgbW9kaWZpZXIga2V5cyBtYXRjaCAocmV0dXJucyB0cnVlIGlmIHRoZXkgZG8pXG4gICAgbW9kaWZpZXJzTWF0Y2ggPSBoYW5kbGVyLm1vZHMubGVuZ3RoID4gMDtcbiAgICBmb3IgKGNvbnN0IHkgaW4gX21vZHMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX21vZHMsIHkpKSB7XG4gICAgICAgIGlmICghX21vZHNbeV0gJiYgaGFuZGxlci5tb2RzLmluZGV4T2YoK3kpID4gLTEgfHwgX21vZHNbeV0gJiYgaGFuZGxlci5tb2RzLmluZGV4T2YoK3kpID09PSAtMSkge1xuICAgICAgICAgIG1vZGlmaWVyc01hdGNoID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDYWxsIHRoZSBoYW5kbGVyIGZ1bmN0aW9uOyBpZ25vcmUgaWYgaXQncyBvbmx5IGEgbW9kaWZpZXIga2V5XG4gICAgaWYgKGhhbmRsZXIubW9kcy5sZW5ndGggPT09IDAgJiYgIV9tb2RzWzE2XSAmJiAhX21vZHNbMThdICYmICFfbW9kc1sxN10gJiYgIV9tb2RzWzkxXSB8fCBtb2RpZmllcnNNYXRjaCB8fCBoYW5kbGVyLnNob3J0Y3V0ID09PSAnKicpIHtcbiAgICAgIGhhbmRsZXIua2V5cyA9IFtdO1xuICAgICAgaGFuZGxlci5rZXlzID0gaGFuZGxlci5rZXlzLmNvbmNhdChfZG93bktleXMpO1xuICAgICAgaWYgKGhhbmRsZXIubWV0aG9kKGV2ZW50LCBoYW5kbGVyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSBldmVudC5wcmV2ZW50RGVmYXVsdCgpO2Vsc2UgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmIChldmVudC5jYW5jZWxCdWJibGUpIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKiBIYW5kbGUgdGhlIGtleWRvd24gZXZlbnQgKi9cbmZ1bmN0aW9uIGRpc3BhdGNoKGV2ZW50LCBlbGVtZW50KSB7XG4gIGNvbnN0IGFzdGVyaXNrID0gX2hhbmRsZXJzWycqJ107XG4gIGxldCBrZXkgPSBldmVudC5rZXlDb2RlIHx8IGV2ZW50LndoaWNoIHx8IGV2ZW50LmNoYXJDb2RlO1xuICAvLyBFbnN1cmUgdGhhdCB3aGVuIGNhcHR1cmluZyBrZXlzdHJva2VzIGluIG1vZGVybiBicm93c2VycyxcbiAgLy8gdXBwZXJjYXNlIGFuZCBsb3dlcmNhc2UgbGV0dGVycyAoc3VjaCBhcyBSIGFuZCByKSByZXR1cm4gdGhlIHNhbWUga2V5IHZhbHVlLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vamF5d2NqbG92ZS9ob3RrZXlzLWpzL3B1bGwvNTE0XG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleVxuICAvLyBDYXBzTG9jayBrZXlcbiAgLy8gVGhlcmUncyBhbiBpc3N1ZSB3aGVyZSBga2V5ZG93bmAgYW5kIGBrZXl1cGAgZXZlbnRzIGFyZSBub3QgdHJpZ2dlcmVkIGFmdGVyIENhcHNMb2NrIGlzIGVuYWJsZWQgdG8gYWN0aXZhdGUgdXBwZXJjYXNlLlxuICBpZiAoZXZlbnQua2V5ICYmIGV2ZW50LmtleS50b0xvd2VyQ2FzZSgpID09PSAnY2Fwc2xvY2snKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEZvcm0gY29udHJvbCBmaWx0ZXI6IGJ5IGRlZmF1bHQsIHNob3J0Y3V0IGtleXMgYXJlIG5vdCB0cmlnZ2VyZWQgaW4gZm9ybSBlbGVtZW50c1xuICBpZiAoIWhvdGtleXMuZmlsdGVyLmNhbGwodGhpcywgZXZlbnQpKSByZXR1cm47XG5cbiAgLy8gSW4gR2Vja28gKEZpcmVmb3gpLCB0aGUgY29tbWFuZCBrZXkgY29kZSBpcyAyMjQ7IHVuaWZ5IGl0IHdpdGggV2ViS2l0IChDaHJvbWUpXG4gIC8vIEluIFdlYktpdCwgbGVmdCBhbmQgcmlnaHQgY29tbWFuZCBrZXlzIGhhdmUgZGlmZmVyZW50IGNvZGVzXG4gIGlmIChrZXkgPT09IDkzIHx8IGtleSA9PT0gMjI0KSBrZXkgPSA5MTtcblxuICAvKipcbiAgICogQ29sbGVjdCBib3VuZCBrZXlzXG4gICAqIElmIGFuIElucHV0IE1ldGhvZCBFZGl0b3IgaXMgcHJvY2Vzc2luZyBrZXkgaW5wdXQgYW5kIHRoZSBldmVudCBpcyBrZXlkb3duLCByZXR1cm4gMjI5LlxuICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNTA0MzkzNC9pcy1pdC1vay10by1pZ25vcmUta2V5ZG93bi1ldmVudHMtd2l0aC1rZXljb2RlLTIyOVxuICAgKiBodHRwOi8vbGlzdHMudzMub3JnL0FyY2hpdmVzL1B1YmxpYy93d3ctZG9tLzIwMTBKdWxTZXAvYXR0LTAxODIva2V5Q29kZS1zcGVjLmh0bWxcbiAgICovXG4gIGlmIChfZG93bktleXMuaW5kZXhPZihrZXkpID09PSAtMSAmJiBrZXkgIT09IDIyOSkgX2Rvd25LZXlzLnB1c2goa2V5KTtcbiAgLyoqXG4gICAqIEplc3QgdGVzdCBjYXNlcyBhcmUgcmVxdWlyZWQuXG4gICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICovXG4gIFsnbWV0YUtleScsICdjdHJsS2V5JywgJ2FsdEtleScsICdzaGlmdEtleSddLmZvckVhY2goa2V5TmFtZSA9PiB7XG4gICAgY29uc3Qga2V5TnVtID0gbW9kaWZpZXJNYXBba2V5TmFtZV07XG4gICAgaWYgKGV2ZW50W2tleU5hbWVdICYmIF9kb3duS2V5cy5pbmRleE9mKGtleU51bSkgPT09IC0xKSB7XG4gICAgICBfZG93bktleXMucHVzaChrZXlOdW0pO1xuICAgIH0gZWxzZSBpZiAoIWV2ZW50W2tleU5hbWVdICYmIF9kb3duS2V5cy5pbmRleE9mKGtleU51bSkgPiAtMSkge1xuICAgICAgX2Rvd25LZXlzLnNwbGljZShfZG93bktleXMuaW5kZXhPZihrZXlOdW0pLCAxKTtcbiAgICB9IGVsc2UgaWYgKGtleU5hbWUgPT09ICdtZXRhS2V5JyAmJiBldmVudFtrZXlOYW1lXSkge1xuICAgICAgLy8gSWYgdGhlIGNvbW1hbmQga2V5IGlzIHByZXNzZWQsIGNsZWFyIGFsbCBub24tbW9kaWZpZXIga2V5cyBleGNlcHQgdGhlIGN1cnJlbnQgZXZlbnQga2V5LlxuICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIGtleXVwIGZvciBub24tbW9kaWZpZXIga2V5cyB3aWxsIE5FVkVSIGJlIHRyaWdnZXJlZCB3aGVuIGNvbW1hbmQgaXMgcHJlc3NlZC5cbiAgICAgIC8vIFRoaXMgaXMgYSBrbm93biBicm93c2VyIGxpbWl0YXRpb24uXG4gICAgICBfZG93bktleXMgPSBfZG93bktleXMuZmlsdGVyKGsgPT4gayBpbiBtb2RpZmllck1hcCB8fCBrID09PSBrZXkpO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICBpZiAoa2V5IGluIF9tb2RzKSB7XG4gICAgX21vZHNba2V5XSA9IHRydWU7XG4gICAgLy8gUmVnaXN0ZXIgc3BlY2lhbCBtb2RpZmllciBrZXlzIHRvIHRoZSBgaG90a2V5c2Agb2JqZWN0XG4gICAgZm9yIChjb25zdCBrIGluIF9tb2RpZmllcikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfbW9kaWZpZXIsIGspKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50S2V5ID0gbW9kaWZpZXJNYXBbX21vZGlmaWVyW2tdXTtcbiAgICAgICAgaG90a2V5c1trXSA9IGV2ZW50W2V2ZW50S2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFhc3RlcmlzaykgcmV0dXJuO1xuICB9XG5cbiAgLy8gQmluZCB0aGUgbW9kaWZpZXIga2V5cyBpbiBtb2RpZmllck1hcCB0byB0aGUgZXZlbnRcbiAgZm9yIChjb25zdCBlIGluIF9tb2RzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfbW9kcywgZSkpIHtcbiAgICAgIF9tb2RzW2VdID0gZXZlbnRbbW9kaWZpZXJNYXBbZV1dO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2pheXdjamxvdmUvaG90a2V5cy9wdWxsLzEyOVxuICAgKiBUaGlzIHNvbHZlcyB0aGUgaXNzdWUgaW4gRmlyZWZveCBvbiBXaW5kb3dzIHdoZXJlIGhvdGtleXMgY29ycmVzcG9uZGluZyB0byBzcGVjaWFsIGNoYXJhY3RlcnMgd291bGQgbm90IHRyaWdnZXIuXG4gICAqIEFuIGV4YW1wbGUgb2YgdGhpcyBpcyBjdHJsK2FsdCttIG9uIGEgU3dlZGlzaCBrZXlib2FyZCB3aGljaCBpcyB1c2VkIHRvIHR5cGUgzrwuXG4gICAqIEJyb3dzZXIgc3VwcG9ydDogaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD1rZXlib2FyZGV2ZW50LWdldG1vZGlmaWVyc3RhdGVcbiAgICovXG4gIGlmIChldmVudC5nZXRNb2RpZmllclN0YXRlICYmICEoZXZlbnQuYWx0S2V5ICYmICFldmVudC5jdHJsS2V5KSAmJiBldmVudC5nZXRNb2RpZmllclN0YXRlKCdBbHRHcmFwaCcpKSB7XG4gICAgaWYgKF9kb3duS2V5cy5pbmRleE9mKDE3KSA9PT0gLTEpIHtcbiAgICAgIF9kb3duS2V5cy5wdXNoKDE3KTtcbiAgICB9XG4gICAgaWYgKF9kb3duS2V5cy5pbmRleE9mKDE4KSA9PT0gLTEpIHtcbiAgICAgIF9kb3duS2V5cy5wdXNoKDE4KTtcbiAgICB9XG4gICAgX21vZHNbMTddID0gdHJ1ZTtcbiAgICBfbW9kc1sxOF0gPSB0cnVlO1xuICB9XG5cbiAgLy8gR2V0IHRoZSBjdXJyZW50IHNjb3BlIChkZWZhdWx0cyB0byAnYWxsJylcbiAgY29uc3Qgc2NvcGUgPSBnZXRTY29wZSgpO1xuICAvLyBIYW5kbGUgYW55IGhvdGtleXMgcmVnaXN0ZXJlZCBhcyAnKidcbiAgaWYgKGFzdGVyaXNrKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3Rlcmlzay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFzdGVyaXNrW2ldLnNjb3BlID09PSBzY29wZSAmJiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nICYmIGFzdGVyaXNrW2ldLmtleWRvd24gfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBhc3Rlcmlza1tpXS5rZXl1cCkpIHtcbiAgICAgICAgZXZlbnRIYW5kbGVyKGV2ZW50LCBhc3Rlcmlza1tpXSwgc2NvcGUsIGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBJZiB0aGUga2V5IGlzIG5vdCByZWdpc3RlcmVkLCByZXR1cm5cbiAgaWYgKCEoa2V5IGluIF9oYW5kbGVycykpIHJldHVybjtcbiAgY29uc3QgaGFuZGxlcktleSA9IF9oYW5kbGVyc1trZXldO1xuICBjb25zdCBrZXlMZW4gPSBoYW5kbGVyS2V5Lmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlMZW47IGkrKykge1xuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgJiYgaGFuZGxlcktleVtpXS5rZXlkb3duIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgaGFuZGxlcktleVtpXS5rZXl1cCkge1xuICAgICAgaWYgKGhhbmRsZXJLZXlbaV0ua2V5KSB7XG4gICAgICAgIGNvbnN0IHJlY29yZCA9IGhhbmRsZXJLZXlbaV07XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzcGxpdEtleVxuICAgICAgICB9ID0gcmVjb3JkO1xuICAgICAgICBjb25zdCBrZXlTaG9ydGN1dCA9IHJlY29yZC5rZXkuc3BsaXQoc3BsaXRLZXkpO1xuICAgICAgICBjb25zdCBfZG93bktleXNDdXJyZW50ID0gW107IC8vIFN0b3JlIHRoZSBjdXJyZW50IGtleSBjb2Rlc1xuICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGtleVNob3J0Y3V0Lmxlbmd0aDsgYSsrKSB7XG4gICAgICAgICAgX2Rvd25LZXlzQ3VycmVudC5wdXNoKGNvZGUoa2V5U2hvcnRjdXRbYV0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2Rvd25LZXlzQ3VycmVudC5zb3J0KCkuam9pbignJykgPT09IF9kb3duS2V5cy5zb3J0KCkuam9pbignJykpIHtcbiAgICAgICAgICAvLyBNYXRjaCBmb3VuZCwgY2FsbCB0aGUgaGFuZGxlclxuICAgICAgICAgIGV2ZW50SGFuZGxlcihldmVudCwgcmVjb3JkLCBzY29wZSwgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGhvdGtleXMoa2V5LCBvcHRpb24sIG1ldGhvZCkge1xuICBfZG93bktleXMgPSBbXTtcbiAgLyoqIExpc3Qgb2YgaG90a2V5cyB0byBoYW5kbGUgKi9cbiAgY29uc3Qga2V5cyA9IGdldEtleXMoa2V5KTtcbiAgbGV0IG1vZHMgPSBbXTtcbiAgLyoqIERlZmF1bHQgc2NvcGUgaXMgJ2FsbCcsIG1lYW5pbmcgZWZmZWN0aXZlIGluIGFsbCBzY29wZXMgKi9cbiAgbGV0IHNjb3BlID0gJ2FsbCc7XG4gIC8qKiBFbGVtZW50IHRvIHdoaWNoIHRoZSBob3RrZXkgZXZlbnRzIGFyZSBib3VuZCAqL1xuICBsZXQgZWxlbWVudCA9IGRvY3VtZW50O1xuICBsZXQgaSA9IDA7XG4gIGxldCBrZXl1cCA9IGZhbHNlO1xuICBsZXQga2V5ZG93biA9IHRydWU7XG4gIGxldCBzcGxpdEtleSA9ICcrJztcbiAgbGV0IGNhcHR1cmUgPSBmYWxzZTtcbiAgLyoqIEFsbG93IG9ubHkgYSBzaW5nbGUgY2FsbGJhY2sgKi9cbiAgbGV0IHNpbmdsZSA9IGZhbHNlO1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24gKG5vIG9wdGlvbnMgcHJvdmlkZWQpXG4gIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbWV0aG9kID0gb3B0aW9uO1xuICB9XG5cbiAgLy8gUGFyc2Ugb3B0aW9ucyBvYmplY3RcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvcHRpb24pID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIGlmIChvcHRpb24uc2NvcGUpIHNjb3BlID0gb3B0aW9uLnNjb3BlOyAvLyBTZXQgc2NvcGVcbiAgICBpZiAob3B0aW9uLmVsZW1lbnQpIGVsZW1lbnQgPSBvcHRpb24uZWxlbWVudDsgLy8gU2V0IGJpbmRpbmcgZWxlbWVudFxuICAgIGlmIChvcHRpb24ua2V5dXApIGtleXVwID0gb3B0aW9uLmtleXVwO1xuICAgIGlmIChvcHRpb24ua2V5ZG93biAhPT0gdW5kZWZpbmVkKSBrZXlkb3duID0gb3B0aW9uLmtleWRvd247XG4gICAgaWYgKG9wdGlvbi5jYXB0dXJlICE9PSB1bmRlZmluZWQpIGNhcHR1cmUgPSBvcHRpb24uY2FwdHVyZTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbi5zcGxpdEtleSA9PT0gJ3N0cmluZycpIHNwbGl0S2V5ID0gb3B0aW9uLnNwbGl0S2V5O1xuICAgIGlmIChvcHRpb24uc2luZ2xlID09PSB0cnVlKSBzaW5nbGUgPSB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJykgc2NvcGUgPSBvcHRpb247XG5cbiAgLy8gSWYgb25seSBvbmUgY2FsbGJhY2sgaXMgYWxsb3dlZCwgdW5iaW5kIHRoZSBleGlzdGluZyBvbmUgZmlyc3RcbiAgaWYgKHNpbmdsZSkgdW5iaW5kKGtleSwgc2NvcGUpO1xuXG4gIC8vIEhhbmRsZSBlYWNoIGhvdGtleVxuICBmb3IgKDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldLnNwbGl0KHNwbGl0S2V5KTsgLy8gU3BsaXQgaW50byBpbmRpdmlkdWFsIGtleXNcbiAgICBtb2RzID0gW107XG5cbiAgICAvLyBJZiBpdCdzIGEgY29tYmluYXRpb24sIGV4dHJhY3QgbW9kaWZpZXIga2V5c1xuICAgIGlmIChrZXkubGVuZ3RoID4gMSkgbW9kcyA9IGdldE1vZHMoX21vZGlmaWVyLCBrZXkpO1xuXG4gICAgLy8gQ29udmVydCBub24tbW9kaWZpZXIga2V5IHRvIGtleSBjb2RlXG4gICAga2V5ID0ga2V5W2tleS5sZW5ndGggLSAxXTtcbiAgICBrZXkgPSBrZXkgPT09ICcqJyA/ICcqJyA6IGNvZGUoa2V5KTsgLy8gJyonIG1lYW5zIG1hdGNoIGFsbCBob3RrZXlzXG5cbiAgICAvLyBJbml0aWFsaXplIGhhbmRsZXIgYXJyYXkgaWYgdGhpcyBrZXkgaGFzIG5vIGhhbmRsZXJzIHlldFxuICAgIGlmICghKGtleSBpbiBfaGFuZGxlcnMpKSBfaGFuZGxlcnNba2V5XSA9IFtdO1xuICAgIF9oYW5kbGVyc1trZXldLnB1c2goe1xuICAgICAga2V5dXAsXG4gICAgICBrZXlkb3duLFxuICAgICAgc2NvcGUsXG4gICAgICBtb2RzLFxuICAgICAgc2hvcnRjdXQ6IGtleXNbaV0sXG4gICAgICBtZXRob2QsXG4gICAgICBrZXk6IGtleXNbaV0sXG4gICAgICBzcGxpdEtleSxcbiAgICAgIGVsZW1lbnRcbiAgICB9KTtcbiAgfVxuICAvLyBSZWdpc3RlciBob3RrZXkgZXZlbnQgbGlzdGVuZXJzIG9uIHRoZSBnbG9iYWwgZG9jdW1lbnRcbiAgaWYgKHR5cGVvZiBlbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cpIHtcbiAgICBpZiAoIWVsZW1lbnRFdmVudE1hcC5oYXMoZWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IGtleWRvd25MaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IGV2ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB3aW5kb3cuZXZlbnQ7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaChldmVudCwgZWxlbWVudCk7XG4gICAgICB9O1xuICAgICAgY29uc3Qga2V5dXBMaXN0ZW5yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgZXZlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHdpbmRvdy5ldmVudDtcbiAgICAgICAgZGlzcGF0Y2goZXZlbnQsIGVsZW1lbnQpO1xuICAgICAgICBjbGVhck1vZGlmaWVyKGV2ZW50KTtcbiAgICAgIH07XG4gICAgICBlbGVtZW50RXZlbnRNYXAuc2V0KGVsZW1lbnQsIHtcbiAgICAgICAga2V5ZG93bkxpc3RlbmVyLFxuICAgICAgICBrZXl1cExpc3RlbnIsXG4gICAgICAgIGNhcHR1cmVcbiAgICAgIH0pO1xuICAgICAgYWRkRXZlbnQoZWxlbWVudCwgJ2tleWRvd24nLCBrZXlkb3duTGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgICAgYWRkRXZlbnQoZWxlbWVudCwgJ2tleXVwJywga2V5dXBMaXN0ZW5yLCBjYXB0dXJlKTtcbiAgICB9XG4gICAgLy8gUmVnaXN0ZXIgZm9jdXMgZXZlbnQgbGlzdGVuZXIgb25jZSB0byBjbGVhciBwcmVzc2VkIGtleXMgb24gd2luZG93IGZvY3VzXG4gICAgaWYgKCF3aW5MaXN0ZW5kRm9jdXMpIHtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICBfZG93bktleXMgPSBbXTtcbiAgICAgIH07XG4gICAgICB3aW5MaXN0ZW5kRm9jdXMgPSB7XG4gICAgICAgIGxpc3RlbmVyLFxuICAgICAgICBjYXB0dXJlXG4gICAgICB9O1xuICAgICAgYWRkRXZlbnQod2luZG93LCAnZm9jdXMnLCBsaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyKHNob3J0Y3V0KSB7XG4gIGxldCBzY29wZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2FsbCc7XG4gIE9iamVjdC5rZXlzKF9oYW5kbGVycykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGNvbnN0IGRhdGFMaXN0ID0gX2hhbmRsZXJzW2tleV0uZmlsdGVyKGl0ZW0gPT4gaXRlbS5zY29wZSA9PT0gc2NvcGUgJiYgaXRlbS5zaG9ydGN1dCA9PT0gc2hvcnRjdXQpO1xuICAgIGRhdGFMaXN0LmZvckVhY2goZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLm1ldGhvZCkge1xuICAgICAgICBkYXRhLm1ldGhvZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqIENsZWFuIHVwIGV2ZW50IGxpc3RlbmVycy4gQWZ0ZXIgdW5iaW5kaW5nLCBjaGVjayB3aGV0aGVyIHRoZSBlbGVtZW50IHN0aWxsIGhhcyBhbnkgaG90a2V5cyBib3VuZC4gSWYgbm90LCByZW1vdmUgaXRzIGV2ZW50IGxpc3RlbmVycy4gKi9cbmZ1bmN0aW9uIHJlbW92ZUtleUV2ZW50KGVsZW1lbnQpIHtcbiAgY29uc3QgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhfaGFuZGxlcnMpLmZsYXQoKTtcbiAgY29uc3QgZmluZGluZGV4ID0gdmFsdWVzLmZpbmRJbmRleChfcmVmNCA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGVsZW1lbnQ6IGVsXG4gICAgfSA9IF9yZWY0O1xuICAgIHJldHVybiBlbCA9PT0gZWxlbWVudDtcbiAgfSk7XG4gIGlmIChmaW5kaW5kZXggPCAwKSB7XG4gICAgY29uc3Qge1xuICAgICAga2V5ZG93bkxpc3RlbmVyLFxuICAgICAga2V5dXBMaXN0ZW5yLFxuICAgICAgY2FwdHVyZVxuICAgIH0gPSBlbGVtZW50RXZlbnRNYXAuZ2V0KGVsZW1lbnQpIHx8IHt9O1xuICAgIGlmIChrZXlkb3duTGlzdGVuZXIgJiYga2V5dXBMaXN0ZW5yKSB7XG4gICAgICByZW1vdmVFdmVudChlbGVtZW50LCAna2V5dXAnLCBrZXl1cExpc3RlbnIsIGNhcHR1cmUpO1xuICAgICAgcmVtb3ZlRXZlbnQoZWxlbWVudCwgJ2tleWRvd24nLCBrZXlkb3duTGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgICAgZWxlbWVudEV2ZW50TWFwLmRlbGV0ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgaWYgKHZhbHVlcy5sZW5ndGggPD0gMCB8fCBlbGVtZW50RXZlbnRNYXAuc2l6ZSA8PSAwKSB7XG4gICAgLy8gUmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMgZnJvbSBhbGwgZWxlbWVudHNcbiAgICBjb25zdCBldmVudEtleXMgPSBPYmplY3Qua2V5cyhlbGVtZW50RXZlbnRNYXApO1xuICAgIGV2ZW50S2V5cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5ZG93bkxpc3RlbmVyLFxuICAgICAgICBrZXl1cExpc3RlbnIsXG4gICAgICAgIGNhcHR1cmVcbiAgICAgIH0gPSBlbGVtZW50RXZlbnRNYXAuZ2V0KGVsKSB8fCB7fTtcbiAgICAgIGlmIChrZXlkb3duTGlzdGVuZXIgJiYga2V5dXBMaXN0ZW5yKSB7XG4gICAgICAgIHJlbW92ZUV2ZW50KGVsLCAna2V5dXAnLCBrZXl1cExpc3RlbnIsIGNhcHR1cmUpO1xuICAgICAgICByZW1vdmVFdmVudChlbCwgJ2tleWRvd24nLCBrZXlkb3duTGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgICAgICBlbGVtZW50RXZlbnRNYXAuZGVsZXRlKGVsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBDbGVhciB0aGUgZWxlbWVudEV2ZW50TWFwXG4gICAgZWxlbWVudEV2ZW50TWFwLmNsZWFyKCk7XG4gICAgLy8gQ2xlYXIgYWxsIGhhbmRsZXJzXG4gICAgT2JqZWN0LmtleXMoX2hhbmRsZXJzKS5mb3JFYWNoKGtleSA9PiBkZWxldGUgX2hhbmRsZXJzW2tleV0pO1xuICAgIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHdpbmRvdyBmb2N1cyBldmVudCBsaXN0ZW5lclxuICAgIGlmICh3aW5MaXN0ZW5kRm9jdXMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGlzdGVuZXIsXG4gICAgICAgIGNhcHR1cmVcbiAgICAgIH0gPSB3aW5MaXN0ZW5kRm9jdXM7XG4gICAgICByZW1vdmVFdmVudCh3aW5kb3csICdmb2N1cycsIGxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICAgIHdpbkxpc3RlbmRGb2N1cyA9IG51bGw7XG4gICAgfVxuICB9XG59XG5jb25zdCBfYXBpID0ge1xuICBnZXRQcmVzc2VkS2V5U3RyaW5nLFxuICBzZXRTY29wZSxcbiAgZ2V0U2NvcGUsXG4gIGRlbGV0ZVNjb3BlLFxuICBnZXRQcmVzc2VkS2V5Q29kZXMsXG4gIGdldEFsbEtleUNvZGVzLFxuICBpc1ByZXNzZWQsXG4gIGZpbHRlcixcbiAgdHJpZ2dlcixcbiAgdW5iaW5kLFxuICBrZXlNYXA6IF9rZXlNYXAsXG4gIG1vZGlmaWVyOiBfbW9kaWZpZXIsXG4gIG1vZGlmaWVyTWFwXG59O1xuZm9yIChjb25zdCBhIGluIF9hcGkpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfYXBpLCBhKSkge1xuICAgIGhvdGtleXNbYV0gPSBfYXBpW2FdO1xuICB9XG59XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgY29uc3QgX2hvdGtleXMgPSB3aW5kb3cuaG90a2V5cztcbiAgaG90a2V5cy5ub0NvbmZsaWN0ID0gZGVlcCA9PiB7XG4gICAgaWYgKGRlZXAgJiYgd2luZG93LmhvdGtleXMgPT09IGhvdGtleXMpIHtcbiAgICAgIHdpbmRvdy5ob3RrZXlzID0gX2hvdGtleXM7XG4gICAgfVxuICAgIHJldHVybiBob3RrZXlzO1xuICB9O1xuICB3aW5kb3cuaG90a2V5cyA9IGhvdGtleXM7XG59XG5cbmV4cG9ydCB7IGhvdGtleXMgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hotkeys-js/dist/hotkeys.esm.js\n");

/***/ })

};
;